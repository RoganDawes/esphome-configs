substitutions:
  name: "gate"
  friendly_name: "Gate"
  project_name: "gate controller"
  project_version: "1.0"

packages:
  common: !include .common.yaml

# Override logging
# logger:
#   level: VERBOSE

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"

esp32:
  board: esp32dev

bluetooth_proxy:

esp32_ble_tracker:

output:
  - platform: gpio
    pin: GPIO2
    id: ped_output
  - platform: gpio
    pin: GPIO16
    id: frx_output
  - platform: gpio
    pin: GPIO18
    id: trg_output

button:
  - platform: output
    id: ped
    name: "Pedestrian"
    output: ped_output
    duration: 500ms
  - platform: output
    id: frx
    name: "Free exit"
    internal: true
    output: frx_output
    duration: 500ms
  - platform: output
    id: trg
    name: "Trigger"
    internal: true
    output: trg_output
    duration: 500ms

cover:
  - platform: template
    name: "Gate"
    device_class: gate
    id: gate
    lambda: |-
      if (id(status).state == "Open") {
        return COVER_OPEN;
      } else if (id(status).state == "Closed") {
        return COVER_CLOSED;
      } else {
        return {};
      }
    open_action:
      - button.press: frx
    stop_action:
      - button.press: trg
    close_action:
      - button.press: trg
    optimistic: false

binary_sensor:
# attached to the status LED via an opto
  - platform: gpio
    pin: 
      number: GPIO21
      mode: input_pullup
      inverted: true
    id: led
    internal: true
    entity_category: diagnostic
    icon: mdi:led-outline
    disabled_by_default: true
    publish_initial_state: true
#    on_state:
#      - then:
#        - lambda: |-
#            static uint32_t last_change = 0;
#            auto now = millis();
#            if (last_change > 0) {
#               ESP_LOGV("main", "LED %s after %dms", x ? "ON" : "OFF", now - last_change);
#            }
#            last_change = now;

  # We use a copy binary_sensor to allow debugging the timing in the primary sensor,
  # without messing with the filters in this copy sensor
  - platform: copy
    source_id: led
    internal: true
    id: copy_led
    entity_category: diagnostic
    icon: mdi:led-outline
    disabled_by_default: true
    filters:
      - delayed_on_off: 50ms
    on_multi_click:
      - timing: # Closed
          - OFF for at least 2000ms
        then:
          - text_sensor.template.publish:
              id: status
              state: "Closed"
          - lambda: |-
              id(gate).current_operation = CoverOperation::COVER_OPERATION_IDLE;
              id(gate).publish_state();
        invalid_cooldown: 50ms

      - timing: # Open
          - ON for at least 2000ms
        then:
          - text_sensor.template.publish:
              id: status
              state: "Open"
          - lambda: |-
              id(gate).current_operation = CoverOperation::COVER_OPERATION_IDLE;
              id(gate).publish_state();
        invalid_cooldown: 50ms

      - timing: # Closing
        - ON for 50ms to 250ms
        - OFF for 50ms to 250ms
        - ON for 50ms to 250ms
        - OFF for 50ms to 250ms
        - ON for 50ms to 250ms
        - OFF for 50ms to 250ms
        then:
          - text_sensor.template.publish:
              id: status
              state: "Closing"
          - lambda: |-
              id(gate).current_operation = CoverOperation::COVER_OPERATION_CLOSING;
              id(gate).publish_state();
        invalid_cooldown: 50ms

      - timing: # Opening - count 6 flashes to be sure this is not an error condition
          - ON for 250ms to 550ms
          - OFF for 250ms to 550ms
          - ON for 250ms to 550ms
          - OFF for 250ms to 550ms
          - ON for 250ms to 550ms
          - OFF for 250ms to 550ms
          - ON for 250ms to 550ms
          - OFF for 250ms to 550ms
          - ON for 250ms to 550ms
          - OFF for 250ms to 550ms
          - ON for 250ms to 550ms
          - OFF for 250ms to 550ms
        then:
          - text_sensor.template.publish:
              id: status
              state: "Opening"
          - lambda: |-
              id(gate).current_operation = CoverOperation::COVER_OPERATION_OPENING;
              id(gate).publish_state();
        invalid_cooldown: 50ms

      - timing: # Pillar light override
          - ON for 200ms to 300ms
          - OFF for 1700ms to 1800ms
        then:
          - logger.log: "Pillar light override"
          - text_sensor.template.publish:
              id: status
              state: "Pillar light override"
        invalid_cooldown: 100ms

      - timing: # No Mains
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 1200ms to 1400ms
        then:
          - logger.log: "No Mains"
          - text_sensor.template.publish:
              id: status
              state: "No Mains"
        invalid_cooldown: 100ms

      - timing: # Battery Low
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 500ms to 1000ms
        then:
          - logger.log: "Low Battery"
          - text_sensor.template.publish:
              id: status
              state: "Low Battery"
        invalid_cooldown: 100ms

      - timing: # Collision detector
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 500ms to 1000ms
        then:
          - logger.log: "Collision Detected"
          - text_sensor.template.publish:
              id: status
              state: "Collision Detected"
        invalid_cooldown: 100ms

      - timing: # Microprocessor reset
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 200ms to 300ms
          - ON for 200ms to 300ms
          - OFF for 500ms to 1000ms
        then:
          - logger.log: "Microprocessor reset"
          - text_sensor.template.publish:
              id: status
              state: "Microprocessor reset"
        invalid_cooldown: 100ms

text_sensor:
  - platform: template
    icon: mdi:information-outline
    id: status
    name: "Status"

